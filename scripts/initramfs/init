#!/bin/busybox sh

# Default PATH differs between shells, and is not automatically exported
# by klibc dash.  Make it consistent.
export PATH=/sbin:/usr/sbin:/bin:/usr/bin

# Provide emergency shell
#
# On failure, provide a shell for debugging. In the case of unattended
# deployments, Automatically reboot after a while if there is no other
# intervention.
emergencysh() {
  ( sleep 30 ; reboot -f ) &
  exec sh
  exit 1
}

# Failure is not an option
#
# The expected outcome is that this script will exec the actual init(8)
# so any exit constitutes failure.
trap 'emergencysh' 0
set -e

[ -d /proc ] || mkdir /proc
mount -t proc none /proc
[ -d /sys ] || mkdir /sys
mount -t sysfs none /sys

#busybox --install -s

mknod /dev/null c 1 3
mknod /dev/tty c 5 0
[ -e /dev/console ] || mknod /dev/console c 5 1

mdev -s

#Hardware specific adaptions

HWDEVICE="$(cat /proc/cpuinfo | grep Hardware | awk '{print $4}' )"
if [ ! x${HWDEVICE} == "x" ]; then
  if [ $HWDEVICE == i.MX6 ]; then
    exec >/dev/kmsg 2>&1 </dev/console
  fi
fi

HWDEVICE="$(cat /proc/cpuinfo | grep Hardware | awk '{print $3}' )"

if [ $HWDEVICE == ODROID-C2 ] ; then
   exec >/dev/kmsg 2>&1 </dev/console
fi

# Odroid C1, SparkySBC, BPI-M2U and Pine64 have overlayfs version < V22
if [ $HWDEVICE == ODROIDC ] || [ $HWDEVICE == gs705a ] || [ $HWDEVICE == sun50iw1p1 ] || [ $HWDEVICE == sun8iw11p1 ]; then
   OVERLAY=NOWRKDIR
   exec >/dev/kmsg 2>&1 </dev/console
else
   OVERLAY=WITHWRKDIR
fi

echo "Booting Volumio for" $HWDEVICE
echo "	This script mounts rootfs RO with an overlay RW layer."

# Do your stuff here.

if [ $OVERLAY == WITHWRKDIR ]; then
   # For overlayfs version V22 or higher (modulename 'overlay')
   modprobe overlay
else
   # For overlayfs version V20/V21 (modulename ='overlayfs')
   modprobe overlayfs
fi
modprobe squashfs
modprobe nls_cp437

# Parse the kernel command line from grub

CMDLINE="$(cat /proc/cmdline)"

find_disk() {
  i=0
  while :
    do
      if "$@" ; then
        break
      fi
      if [ "$i" -eq 30 ]; then
        echo "No partition with $1 has been found"
        exit 1
      fi
      echo "$1 not detected, retrying mdev"
      sleep 1
      i=$((i + 1))
      mdev -s
    done >&2
}

parse_disk() {
  if [ -n "$1" -a "${1##UUID=*}" ]; then
    find_disk findfs "$1"
    findfs "$1"
  elif [ -n "$1" -a "${1##LABEL=*}" ]; then
    find_disk findfs "$1"
    findfs "$1"
  elif [ -n "$1" -a "${1##/dev/*}" ]; then
    find_disk test -b "$1"
    echo "$1"
  fi
}

usage() {
  echo "$1"
  echo "Current kernel command ${CMDLINE}"
  echo "example: ... imgpart=/dev/sda2 imgfile=/gentoo.sqs imgdata=/dev/sda3"
  exec sh
  exit 1
}


for p in ${CMDLINE};
do
  key=${p%%=*}
  value=${p#*=}

  case $key in
  imgpartopt)
    IMGPARTOPT=$value
    ;;
  imgpart)
    IMGPART=$value
    ;;
  imgfile)
    IMGFILE=$value
    ;;
  imgdataopt)
    IMGDATAOPT=$value
    ;;
  imgdata)
    IMGDATA=$value
    ;;
  esac
done

echo IMGPART=${IMGPART}
echo IMGPARTOPT=${IMGPARTOPT}
echo IMGFILE=${IMGFILE}
echo IMGDATA=${IMGDATA}
echo IMGDATAOPT=${IMGDATAOPT}

IMGPART=$(parse_disk "$IMGPART")
IMGDATA=$(parse_disk "$IMGDATA")

[ -n "${IMGPART}" ] ||
  usage "Specify the squash image partition"

[ -n "${IMGFILE}" ] ||
  usage "Specify the squash image file"

[ -n "${IMGDATA}" ] ||
  echo "Specify the data partition"

[ x"${IMGDATA}" != x"${IMGPART}" ] ||
  echo "Specify different image and data partitions"

# ok, parsing done
[ -d /mnt ] || mkdir /mnt
# Mount the partitions
# 1) mount the partition where the squash image resides
[ -d /mnt/imgpart ] || mkdir /mnt/imgpart
mount -t ext4 -o noatime"${IMGPARTOPT:+,$IMGPARTOPT}" "${IMGPART}" /mnt/imgpart

#check for recovery image, if not found create it
if [ ! -e "/mnt/imgpart/volumio_factory.sqsh" ]; then
  echo "Creating factory image, this will take a minute, please wait..."
  cp /mnt/imgpart/volumio_current.sqsh /mnt/imgpart/volumio_factory.sqsh
  echo "Factory image created"
fi


#Check eventually for USB updates (could be vfat or ext4 partion --> mount auto)
echo "Check for USB updates"
if [ -e /dev/sda1 ]; then
  [ -d /mnt/usb ] || mkdir /mnt/usb
  grep '^/dev/sda1 ' /proc/mounts |
    if read DEV DIR OTHER ; then
      mount --bind "$DIR" /mnt/usb
    else
      mount -t auto /dev/sda1 /mnt/usb
    fi
  #If there is a firmware file inside the usb
  if [ -e /mnt/usb/volumio.fir ]; then
	echo "Firmware found, updating will take a few minutes, please wait..."
    #when the partitions are mounted we can launch the update script
    volumio-init-updater
  fi
  if [ -e /mnt/usb/factory_reset ]; then
    echo "Factory Reset on USB"
    mkdir /mnt/factory
    mount -t auto /dev/mmcblk0p1 /mnt/factory
    echo " " > /mnt/factory/factory_reset
    umount /mnt/factory
    rm -r /mnt/factory
  fi
  umount /mnt/usb
  rm -r /mnt/usb
fi


# 2) init a loop pointing to the image file
[ -e /dev/loop0 ] || mknod /dev/loop0 b 7 0
losetup /dev/loop0 "/mnt/imgpart/${IMGFILE}"


# 3) mount the squashfs to /mnt/static
[ -d /mnt/static ] || mkdir /mnt/static
mount -t squashfs /dev/loop0 /mnt/static

VOLUMIO_VERSION="$(cat /mnt/static/etc/os-release | grep VOLUMIO_VERSION)"

#if there is factory file then format data partition
mkdir /mnt/factory
mount -t vfat /dev/mmcblk0p1 /mnt/factory
if [ -e "/mnt/factory/factory_reset" ]; then
  echo "Executing factory reset"
  mkfs.ext4 -F -E stride=2,stripe-width=1024 -b 4096 /dev/mmcblk0p3 -L volumio_data

  echo "Factory reset executed: part I"
  cp  /mnt/imgpart/volumio_factory.sqsh /mnt/imgpart/volumio_current.sqsh && rm /mnt/factory/factory_reset
  echo "Factory reset executed: part II - end"
fi
if [ -e "/mnt/factory/user_data" ]; then
  echo "Deleting User Data"
  mkfs.ext4 -F -E stride=2,stripe-width=1024 -b 4096 /dev/mmcblk0p3 -L volumio_data
  rm /mnt/factory/user_data
  
  echo "User Data successfully deleted "
fi
umount /mnt/factory
rm -r /mnt/factory

mkdir boot
mount -t vfat /dev/mmcblk0p1 /boot
if [ -e "/boot/resize-volumio-datapart" ]; then
echo "Re-sizing Volumio data partition"
  END="$(parted -s /dev/mmcblk0 unit MB print free | grep Free | tail -1 | awk '{print $2}' | grep -o '[0-9]\+')"
  parted -s /dev/mmcblk0 resizepart 3 ${END}
  e2fsck -fy /dev/mmcblk0p3
  resize2fs /dev/mmcblk0p3
  echo "Volumio data partition succesfully resized"
  parted -s /dev/mmcblk0 unit MB print
  rm /boot/resize-volumio-datapart
fi
umount /boot
rm -r /boot

# 4) mount a filesystem for write access to the static image
# unclear: memory size? -o size=1024M
[ -d /mnt/ext ] || mkdir -m 777 /mnt/ext
mount -t ext4 -o noatime"${IMGDATAOPT:+,$IMGDATAOPT}" "${IMGDATA}" /mnt/ext

[ -d /mnt/ext/dyn ] || mkdir -m 777 /mnt/ext/dyn
[ -d /mnt/ext/union ] || mkdir -m 777 /mnt/ext/union

# 5) mount the writable overlay to the static image
if [ $OVERLAY == WITHWRKDIR ]; then
  [ -d /mnt/ext/work ] || mkdir -m 777 /mnt/ext/work
  echo "With Option:" $OVERLAY
  mount -t overlay -olowerdir=/mnt/static,upperdir=/mnt/ext/dyn,workdir=/mnt/ext/work overlay /mnt/ext/union
else
  echo "Without Option:" $OVERLAY
  mount -t overlayfs overlayfs /mnt/ext/union -olowerdir=/mnt/static,upperdir=/mnt/ext/dyn
fi

[ -d /mnt/ext/union/static ] || mkdir -m 777 /mnt/ext/union/static
[ -d /mnt/ext/union/imgpart ] || mkdir -m 777 /mnt/ext/union/imgpart
mount --move /mnt/static /mnt/ext/union/static
mount --move /mnt/imgpart /mnt/ext/union/imgpart

umount /proc
umount /sys

echo ${VOLUMIO_VERSION}
echo "Finish initramfs, continue booting Volumio"
exec switch_root /mnt/ext/union /sbin/init

echo "Failed to switch_root, dropping to a shell"
exit 1
